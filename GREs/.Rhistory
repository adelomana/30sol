install.packages('devtools', dep=T)
library(devtools)
install_github('cMonkeyNwInf','djreiss',subdir='cMonkeyNwInf')
load("~/gDrive2/projects/help/ben/Inferelator-run.TanayAndSGE.noAnd.2014-05-27.392.0.200.Exp.2941.withTFs.RData")
master.coeffs$coeffs
load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/src/EGRINcommands/inferelatorResult.RData')
# 1. create matrix of all zeros with 1-row for each target gene and 1-col for each putative regulator.
regNames <- unique(unlist(lapply(coeffs, function(x) {names(x$coeffs)})))
targNames <- names(coeffs)
outMatrix <- matrix(0, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
# 2. loop through each each element in master.coeffs and put the values from coef.quantiles into the table. Here's some poorly tested code:
for (i in 1:length(coeffs)) {
targ <- names(coeffs)[i]
if (is.matrix(coeffs[[i]]$coef.quantiles)) {
coeffValues <- coeffs[[i]]$coef.quantiles[,'5%']
outMatrix[targ, names(coeffValues)] <- coeffValues
}
}
# 3 write the table
write.csv(outMatrix, file='regPrograms.5percent.csv')
load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/src/EGRINcommands/inferelatorResult.RData')
# 1. create matrix of all zeros with 1-row for each target gene and 1-col for each putative regulator.
regNames <- unique(unlist(lapply(coeffs, function(x) {names(x$coeffs)})))
targNames <- names(coeffs)
outMatrix <- matrix(0, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
# 2. loop through each each element in master.coeffs and put the values from coef.quantiles into the table. Here's some poorly tested code:
for (i in 1:length(coeffs)) {
targ <- names(coeffs)[i]
if (is.matrix(coeffs[[i]]$coef.quantiles)) {
coeffValues <- coeffs[[i]]$coef.quantiles[,'5%']
p-value=1-coeffs[[i]]$coef.quantiles[,'n']
#linearCoeff=coeffs[[i]]$coef.quantiles[,'95%']
outMatrix[targ, names(coeffValues)] <- p-value
}
}
# 3 write the table
write.csv(outMatrix, file='regPrograms.5percent.csv')
load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/src/EGRINcommands/inferelatorResult.RData')
# 1. create matrix of all zeros with 1-row for each target gene and 1-col for each putative regulator.
regNames <- unique(unlist(lapply(coeffs, function(x) {names(x$coeffs)})))
targNames <- names(coeffs)
outMatrix <- matrix(0, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
# 2. loop through each each element in master.coeffs and put the values from coef.quantiles into the table. Here's some poorly tested code:
for (i in 1:length(coeffs)) {
targ <- names(coeffs)[i]
if (is.matrix(coeffs[[i]]$coef.quantiles)) {
coeffValues <- coeffs[[i]]$coef.quantiles[,'5%']
pvalue=1-coeffs[[i]]$coef.quantiles[,'n']
#linearCoeff=coeffs[[i]]$coef.quantiles[,'95%']
outMatrix[targ, names(pvalue)] <- pvalue
}
}
# 3 write the table
write.csv(outMatrix, file='regPrograms.5percent.csv')
load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/src/EGRINcommands/inferelatorResult.RData')
# 1. create matrix of all zeros with 1-row for each target gene and 1-col for each putative regulator.
regNames <- unique(unlist(lapply(coeffs, function(x) {names(x$coeffs)})))
targNames <- names(coeffs)
outMatrix <- matrix(1, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
# 2. loop through each each element in master.coeffs and put the values from coef.quantiles into the table. Here's some poorly tested code:
for (i in 1:length(coeffs)) {
targ <- names(coeffs)[i]
if (is.matrix(coeffs[[i]]$coef.quantiles)) {
coeffValues <- coeffs[[i]]$coef.quantiles[,'5%']
pvalue=1-coeffs[[i]]$coef.quantiles[,'n']
#linearCoeff=coeffs[[i]]$coef.quantiles[,'95%']
outMatrix[targ, names(pvalue)] <- pvalue
}
}
# 3 write the table
write.csv(outMatrix, file='regPrograms.5percent.csv')
load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/src/EGRINcommands/inferelatorResult.RData')
# 1. create matrix of all zeros with 1-row for each target gene and 1-col for each putative regulator.
regNames <- unique(unlist(lapply(coeffs, function(x) {names(x$coeffs)})))
targNames <- names(coeffs)
pValuesMatrix <- matrix(1, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
coefficientsMatrix <- matrix(0, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
# 2. loop through each each element in master.coeffs and put the values from coef.quantiles into the table. Here's some poorly tested code:
for (i in 1:length(coeffs)) {
targ <- names(coeffs)[i]
if (is.matrix(coeffs[[i]]$coef.quantiles)) {
coeffValues <- coeffs[[i]]$coef.quantiles[,'5%']
pvalue=1-coeffs[[i]]$coef.quantiles[,'n']
#linearCoeff=coeffs[[i]]$coef.quantiles[,'95%']
coefficientsMatrix[targ, names(coeffValues)] <- coeffValues
pValuesMatrix[targ, names(pvalue)] <- pvalue
}
}
# 3 write the table
write.csv(coefficientsMatrix, file='coefficients.csv')
write.csv(coefficientsMatrix, file='pvalues.csv')
#load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/src/EGRINcommands/inferelatorResult.RData')
load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/results/EGRIN/version.3/inferelator/inferelator-coeffs.RData')
# 1. create matrix of all zeros with 1-row for each target gene and 1-col for each putative regulator.
regNames <- unique(unlist(lapply(coeffs, function(x) {names(x$coeffs)})))
targNames <- names(coeffs)
pValuesMatrix <- matrix(1, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
coefficientsMatrix <- matrix(0, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
# 2. loop through each each element in master.coeffs and put the values from coef.quantiles into the table. Here's some poorly tested code:
for (i in 1:length(coeffs)) {
targ <- names(coeffs)[i]
if (is.matrix(coeffs[[i]]$coef.quantiles)) {
coeffValues <- coeffs[[i]]$coef.quantiles[,'5%']
pvalue=1-coeffs[[i]]$coef.quantiles[,'n']
#linearCoeff=coeffs[[i]]$coef.quantiles[,'95%']
coefficientsMatrix[targ, names(coeffValues)] <- coeffValues
pValuesMatrix[targ, names(pvalue)] <- pvalue
}
}
# 3 write the table
write.csv(coefficientsMatrix, file='coefficients.csv')
write.csv(coefficientsMatrix, file='pvalues.csv')
#load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/src/EGRINcommands/inferelatorResult.RData')
load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/results/EGRIN/version.3/inferelator/inferelator-coeffs.RData')
# 1. create matrix of all zeros with 1-row for each target gene and 1-col for each putative regulator.
regNames <- unique(unlist(lapply(coeffs, function(x) {names(x$coeffs)})))
targNames <- names(coeffs)
pValuesMatrix <- matrix(1, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
coefficientsMatrix <- matrix(0, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
# 2. loop through each each element in master.coeffs and put the values from coef.quantiles into the table. Here's some poorly tested code:
for (i in 1:length(coeffs)) {
targ <- names(coeffs)[i]
if (is.matrix(coeffs[[i]]$coef.quantiles)) {
coeffValues <- coeffs[[i]]$coef.quantiles[,'5%']
pvalue=1-coeffs[[i]]$coef.quantiles[,'n']
#linearCoeff=coeffs[[i]]$coef.quantiles[,'95%']
coefficientsMatrix[targ, names(coeffValues)] <- coeffValues
#pValuesMatrix[targ, names(pvalue)] <- pvalue
}
}
# 3 write the table
write.csv(coefficientsMatrix, file='coefficients.csv')
write.csv(coefficientsMatrix, file='pvalues.csv')
#load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/src/EGRINcommands/inferelatorResult.RData')
load('/Users/alomana/gDrive2/projects/TREES-C/PfuEGRIN/results/EGRIN/version.3/inferelator/inferelator-coeffs.RData')
# 1. create matrix of all zeros with 1-row for each target gene and 1-col for each putative regulator.
regNames <- unique(unlist(lapply(coeffs, function(x) {names(x$coeffs)})))
targNames <- names(coeffs)
pValuesMatrix <- matrix(1, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
coefficientsMatrix <- matrix(0, nrow=length(targNames), ncol=length(regNames), dimnames=list(targNames, regNames))
# 2. loop through each each element in master.coeffs and put the values from coef.quantiles into the table. Here's some poorly tested code:
for (i in 1:length(coeffs)) {
targ <- names(coeffs)[i]
if (is.matrix(coeffs[[i]]$coef.quantiles)) {
coeffValues <- coeffs[[i]]$coef.quantiles[,'5%']
pvalue=1-coeffs[[i]]$coef.quantiles[,'n']
#linearCoeff=coeffs[[i]]$coef.quantiles[,'95%']
coefficientsMatrix[targ, names(coeffValues)] <- coeffValues
pValuesMatrix[targ, names(pvalue)] <- pvalue
}
}
# 3 write the table
write.csv(coefficientsMatrix, file='coefficients.csv')
write.csv(pValuesMatrix, file='pvalues.csv')
install.packages("idr")
library("idr")
### cleaning all variables in the session
closeAllConnections()
rm(list=ls())
# 0.1. loading external packages. if library is missing in your computer, use the R command: install.packages('name of the library')
library(Rtsne) # implementation of t-SNE algorithm
library(RColorBrewer) # library to access easily multiple colors for plotting
library(tictoc) # library to profile execution time
library(scatterplot3d) # library for static 3D plotting
library(randomForest) # a library that includes an implementation of a random forest algorithm
# 0.2. user-specific definition of paths.
# please navigate into "case.melanoma" through the "Files" tab on the bottom right, and set that directory as your working directory
dataDirectory='../../data/case.melanoma/formatted/'
# 1. reading the data and metadata for malignant cells
print('reading and treating data...')
dataFilePath=paste(dataDirectory,'nonMalignant.2kgenes.data.testing.csv',sep='')
metadataFilePath=paste(dataDirectory,'nonMalignant.2kgenes.tumorMetadata.testing.csv',sep='')
originalData=read.csv(dataFilePath,header=TRUE,row.names=1)
expression=as.data.frame(t(originalData)) # transposing the original data into the appropriate form: 2,249 observations in a 2,000 dimensional space
names(expression)=make.names(names(expression))
tumorMetadata=read.csv(metadataFilePath,header=TRUE,row.names=1)
# 2. dimensionality reduction of original data
# 2.1. setting some variables for plotting
tumorLabels=as.character(tumorMetadata$tumor.label)
plottingColors=brewer.pal(length(unique(tumorLabels)),'Dark2')
names(plottingColors)=unique(tumorLabels)
# 2.2. high resolution of t-SNE
print('running 2D t-SNE with large perplexity...')
tic()
results2D=Rtsne(expression,dims=2,perplexity=50,verbose=TRUE,theta=0)
toc()
# plotting
pdf('figure.non.malignantCells.tsne.2d.pdf')
plot(results2D$Y,main='tSNE of non malignant cells, p=50',col=plottingColors[tumorLabels],pch=19,xlab='tSNE Component 1',ylab='tSNE Component 2')
legend('topright',legend=unique(tumorLabels),fill=plottingColors[unique(tumorLabels)])
dev.off() # don't forget this command, otherwise the PDF fil
# 1. reading the data and metadata for malignant cells
print('reading and treating data...')
dataFilePath=paste(dataDirectory,'nonMalignant.2kgenes.data.testing.csv',sep='')
metadataFilePath=paste(dataDirectory,'nonMalignant.2kgenes.tumorMetadata.testing.csv',sep='')
originalData=read.csv(dataFilePath,header=TRUE,row.names=1)
expression=as.data.frame(t(originalData)) # transposing the original data into the appropriate form: 2,249 observations in a 2,000 dimensional space
names(expression)=make.names(names(expression))
tumorMetadata=read.csv(metadataFilePath,header=TRUE,row.names=1)
#################################################################
# @Course: Systems Biology of Disease                           #
# @Rscript: gbmCode.R                                             #
# @Version: 1                                                   #
# @Author: Chris Plaisier and Adrian de Lomana                  #
# @Sponsored by:                                                #
# Institute for Systems Biology                                 #
# 1441 North 34th Street                                        #
# Seattle, Washington  98103-8904                               #
# (216) 732-2139                                                #
#                                                               #
# Copyright (C) 2016 by Institute for Systems Biology,          #
# Seattle, Washington, USA.  All rights reserved.               #
#                                                               #
# This source code is distributed under the GNU Lesser          #
# General Public License, the text of which is available at:    #
#   http://www.gnu.org/copyleft/lesser.html                     #
#################################################################
#####################################
### Libraries needed for analysis ###
#####################################
library(RColorBrewer)
library(scatterplot3d)
library(rgl)
library(Rtsne)
library(tictoc)
##############################
### Load data for analysis ###
##############################
# Set working directory
# please navigate into "case.gbm" through the "Files" tab on the bottom right, and set that directory as your working directory
# Read in expression data from GEO GSE57872 for glioblastoma single cells
d1 = read.csv('../../data/case.gbm/GSE57872_GBM_data_matrix.csv', header=1, row.names=1)
##################################
### Exploring single cell data ###
##################################
# Prepare to colorize based on single cell tumor origin
colNames1 = sapply(colnames(d1)[1:430], function(x) { strsplit(x,'_')[[1]][1] } )
colNames1[which(colNames1=='MGH264')] = 'MGH26' # MGH264 is MGH26
col1 = brewer.pal(5, "Dark2")
names(col1) = unique(colNames1)
cols1 = c(as.character(paste(col1[colNames1],'66',sep='')), col1)
cex1 = c(rep(1,430),rep(2,5))
#################
## Compute PCA ##
#################
pca1 = prcomp(t(d1))
# Static 2D plot of PCA
pdf('pca_2D_tumorColorized.pdf')
plot(pca1$x[,'PC1'], pca1$x[,'PC2'], main="GBM single cell PCA", col=cols1, pch=19, cex=cex1)
legend('topright', legend=unique(colNames1), fill=col1[unique(colNames1)], border=F, title='Tumor')
dev.off()
# Static 3D scatter plot of PCA
pdf('pca_3D_tumorColorized.pdf')
scatterplot3d(pca1$x[,1], pca1$x[,2], pca1$x[,3], color=cols1, pch=19, type='p', cex.symbols=cex1, xlab='PCA1', ylab='PCA2', zlab='PCA3')
legend('topleft', legend=unique(colNames1), fill=col1[unique(colNames1)], border=F, title='Tumor')
dev.off()
# Interactive 3D scatter plot of PCA
par3d(windowRect=c(50,50,700,700))
plot3d(pca1$x[,1], pca1$x[,2], pca1$x[,3], col=cols1, type='s', size=cex1, xlab='PCA1', ylab='PCA2', zlab='PCA3')
legend3d('topright', legend=unique(colNames1), fill=col1[unique(colNames1)])
legend3d('topright', legend=unique(colNames1), fill=col1[unique(colNames1)]) # Do legend twice because of bug in RGL
play3d(spin3d(), duration=20)
install.packages('biclust')
test <- matrix(rbinom(400, 50, 0.4), 20, 20)
library('biclust')
res1 <- biclust(test, method=BCCC(), delta=1.5, alpha=1, number=10)
res1
test
res1
data=read.table('foo.csv', header = FALSE, sep = ",")
setwd("~/github/30sols/GREs")
data=read.table('foo.csv', header = FALSE, sep = ",")
res1 <- biclust(data, method=BCCC(), delta=1.5, alpha=1, number=10)
data=matrix(read.table('foo.csv', header = FALSE, sep = ","))
View(data)
res1 <- biclust(data, method=BCCC(), delta=1.5, alpha=1, number=10)
data=as.matrix(read.table('foo.csv', header = FALSE, sep = ","))
View(data)
res1 <- biclust(data, method=BCCC(), delta=1.5, alpha=1, number=10)
res1
jaccardind(res1,data)
drawHeatmap(data,bicResult=res1)
# reading data
data=as.matrix(read.table('foo.csv', header = FALSE, sep = ","))
# computing bicluster
res1 = biclust(data, method=BCCC(), delta=1.5, alpha=1, number=10)
# plotting data before and after
#jaccardind(res1,data)
drawHeatmap(data,bicResult=res1)
drawHeatmap(data,res1)
drawHeatmap(data,res1,1)
drawHeatmap2(data,plotAll=TRUE)
drawHeatmap2(data,res1,plotAll=TRUE)
drawHeatmap2(data,bicResult=res1,plotAll=TRUE)
drawHeatmap2(data,bicResult=res1)
drawHeatmap2(data,bicResult=res1,1)
drawHeatmap2(data,bicResult=res1,2)
drawHeatmap2(data,bicResult=res1,3)
drawHeatmap2(data,bicResult=res1,4)
drawHeatmap2(data,bicResult=res1,1,plotAll=TRUE)
drawHeatmap2(data,bicResult=res1,plotAll=TRUE)
drawHeatmap2(data,plotAll=TRUE)
drawHeatmap2(data,bicResult=res1,number=NULL,plotAll=TRUE)
drawHeatmap2(data,bicResult=res1,number=1,plotAll=TRUE)
drawHeatmap2(data,bicResult=res1,number=1)
# computing bicluster
hc <- hclust(dist(data))
plot(hc)
hc <- pvclust(dist(data))
install.packages('pvclust')
hc <- pvclust(data,method.hclust="ward.D2",method.dist="euclidean")
library('pvclust')
data=read.table('foo.csv', header = FALSE, sep = ",")
hc <- pvclust(data,method.hclust="ward.D2",method.dist="euclidean")
install.packages('pheatmap')
library('pheatmap')
pheatmap(data)
pheatmap(data)
pheatmap(data)
pheatmap(data,kmeans_k=3)
pheatmap(data,kmeans_k=10)
pheatmap(data)
result=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=100)
result
result=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=100)
result
plot(result)
print(result)
result=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=1000,parallel=TRUE)
plot(result)
pheatmap(data)
plot(result)
result=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=10,parallel=TRUE)
plot(result)
result=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=1000,parallel=TRUE)
plot(result)
result=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=10000,parallel=TRUE)
plot(result)
pvrect(result)
permutationIterations=100
result=pvclust(data.T,method.hclust="ward.D2",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(result)
pvrect(result)
permutationIterations=1000
result=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(result)
pvrect(result)
print(result, digits=3)
msplot(result)
permutationIterations=1000
result=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(result)
pvrect(result)
print(result, digits=3)
significantClusters <- pvpick(result)
significantClusters
# computing bicluster
permutationIterations=1000
result=pvclust(t(data),method.hclust="ward.D2",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(result)
pvrect(result)
print(result, digits=3)
significantClusters <- pvpick(result)
significantClusters
dev.off()
permutationIterations=10
result=pvclust(t(data),method.hclust="ward.D2",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(result)
pvrect(result)
print(result, digits=3)
significantClusters <- pvpick(result)
significantClusters
pheatmap(data)
# 2.1. clustering GREs (Vi)
GREclusterResults=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(result)
pvrect(result)
significantClusters <- pvpick(result)
significantClusters
permutationIterations=100
# 2.1. clustering GREs (Vi)
GREclusterResults=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(result)
pvrect(result)
significantClusters <- pvpick(result)
significantClusters
pheatmap(data)
# 2.1. clustering GREs (Vi)
GREclusterResults=pvclust(data,method.hclust="ward.D2",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(GREclusterResults)
pvrect(GREclusterResults)
significantClusters=pvpick(GREclusterResults)
significantClusters
# 2.1. clustering GREs (Vi)
GREclusterResults=pvclust(data,method.hclust="complete",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(GREclusterResults)
pvrect(GREclusterResults)
significantClusters=pvpick(GREclusterResults)
significantGREclusters
# 2.1. clustering GREs (Vi)
GREclusterResults=pvclust(data,method.hclust="complete",method.dist="euclidean",nboot=permutationIterations,parallel=TRUE)
plot(GREclusterResults)
pvrect(GREclusterResults)
significantGREclusters=pvpick(GREclusterResults)
significantGREclusters
Heatmap(data, cluster_columns = GREclusterResults$hclust)
install.packages('MASS')
install.packages("MASS")
install.packages("MASS")
